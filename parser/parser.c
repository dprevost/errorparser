/*
 * Copyright (C) 2008 Daniel Prevost <dprevost@users.sourceforge.net>
 *
 * This file may be distributed and/or modified under the terms of the
 * MIT License as described by the Open Source Initiative
 * (http://opensource.org/licenses/mit-license.php) and appearing in
 * the file COPYING included in the packaging of this software.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

#include "parser.h"

void addGroup( errp_common * commonArgs, xmlNode * group, int last );

const char * g_barrier = "/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */";

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

/*
 * This function strips unwanted characters from a UTF-8 string.
 * From what I understand, the specs of XML parsing guarantee that everything
 * between the open and close tags is kept (the parser cannot know what
 * is needed and what can be safely removed). So the text in this construct
    <notice>
      Nothing.
    </notice>
 * will be saved as: "\n      Nothing.\n    " which is obviously not what
 * we want. We strip to a one-line string (removing all whitespace at the 
 * beginning and end and stripping all duplicate white spaces in the middle.
 */
xmlChar * stripText( xmlChar * inStr )
{
   xmlChar* outStr = NULL;
   
   int size, start, end, i, j;
   
   end = size = xmlStrlen(inStr);
   start = 0;
   
   outStr = calloc( (size+1), sizeof(xmlChar) );
   if ( outStr == NULL ) {
      fprintf( stderr, "Malloc error\n" );
      exit(1);
   }

   /* Replace all unwanted characters by spaces. */
   for ( i = 0; i < size; ++i ) {
      /* Carriage return... just in case */
      if ( inStr[i] == 0x0D ) inStr[i] = 0x20;
      /* New Line */
      if ( inStr[i] == 0x0A ) inStr[i] = 0x20;
      /* Tabs */
      if ( inStr[i] == 0x09 ) inStr[i] = 0x20;
   }

   /* Where does the string really start? */
   for ( i = 0; i < size; ++i ) {
      if ( inStr[i] != 0x20 ) break;
   }
   start = i;
   
   /* And where does it end? */
   for ( i = size-1; i > start; --i ) {
      if ( inStr[i] != 0x20 ) break;
   }
   end = i;
   
   /* Multiple spaces - let's get rid of them */
   outStr[0] = inStr[start];
   for ( i = start+1, j = 1; i <= end; ++i ) {
      if ( inStr[i] == 0x20 && inStr[i-1] == 0x20 ) continue;
      outStr[j] = inStr[i];
      j++;
   }
   
   return outStr;
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

xmlChar * prettify( xmlChar* inStr, char* prefix, int lineLength )
{
   xmlChar* outStr = NULL;   
   int size, i, lines, j, k, lastWhite, start;
   char newLine[1];

   newLine[0] = 0x0A;
   size = xmlStrlen(inStr);
   
   lines = size / lineLength + 2; /* To be safe */
   outStr = calloc( size+lines*(strlen(prefix)+1), sizeof(xmlChar) );
   if ( outStr == NULL ) {
      fprintf(stderr, "Malloc error\n" );
      exit(1);
   }

   strcat( (char*)outStr, prefix );
   j = strlen(prefix);
   for ( i = 0, k = 0, start = 0, lastWhite = -1; i < size; ++i ) {

      if ( j == lineLength ) {
         strncat( (char*)outStr, (char*)&inStr[start], lastWhite-start );
         strncat( (char*)outStr, newLine, 1 );
         strcat( (char*)outStr, prefix );

         j = lineLength - lastWhite + start;

         start = lastWhite + 1;
         lastWhite = -1;
      }

      if ( inStr[i] == 0x20 ) lastWhite = i;
      j++;

      
   }

   if ( j > 0 ) {
      strncat( (char*)outStr, (char*)&inStr[start], size-start+1 );
   }
   return outStr;
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */
void doTopOfFile( errp_common * commonArgs,
                  xmlChar     * version,
                  xmlNode     * copyNode ) 
{
   char timeBuf[30];
#if defined (WIN32)
   char tmpTime[9];
#else
   time_t t;
   struct tm * formattedTime;
#endif
   xmlNode * node;
   xmlChar * years, * authors, * notice, * tmp;
   int i;
   
   memset( timeBuf, '\0', 30 );

#if defined (WIN32)
   _strdate( timeBuf );
   _strtime( tmpTime );
   strcat( timeBuf, " " );
   strcat( timeBuf, tmpTime );
#else
   t = time(NULL);
   formattedTime = localtime( &t );
   strftime( timeBuf, 30, "%a %b %e %H:%M:%S %Y", formattedTime );
#endif

   fprintf( commonArgs->fpHeader, "/*\n" );
   fprintf( commonArgs->fpHeader, " * This file was generated by the program errorParser\n" );
   fprintf( commonArgs->fpHeader, " * using the input file %s.\n", commonArgs->xmlFileName );
   fprintf( commonArgs->fpHeader, " * Date: %s.\n *\n", timeBuf );
   fprintf( commonArgs->fpHeader, " * The version of this interface is %s.\n *\n", version );

   if ( copyNode != NULL ) {
      /* We extract the copyright element to be able to print them. */
      node = copyNode->children;
   
      /* Go to the first element */
      while ( node->type != XML_ELEMENT_NODE ) { node = node->next; }
      years = stripText( node->children->content );
   
      /* Go to the next element */
      do { node = node->next; } while ( node->type != XML_ELEMENT_NODE );
      authors = stripText( node->children->content );
   
      fprintf( commonArgs->fpHeader, " * Copyright (C) %s %s\n", years, authors );
      free( years );
      free( authors );
   
      node = node->next;
      while ( node != NULL ) {
         if ( node->type == XML_ELEMENT_NODE ) {
            fprintf( commonArgs->fpHeader, " *\n" );
            tmp = stripText( node->children->content );
            notice = prettify( tmp, " * ", 72 );
         
            fprintf( commonArgs->fpHeader, "%s\n", notice );
         
            free( tmp );
            free( notice );
         }
         node = node->next;
      }
   }
   fprintf( commonArgs->fpHeader, " */\n\n%s\n\n", g_barrier );
   
   for ( i = 0; i < strlen(commonArgs->headerName); ++i ) {
      if ( isalnum(commonArgs->headerName[i]) ) {
         if ( isalpha(commonArgs->headerName[i]) ) {
            commonArgs->headerName[i] = toupper(commonArgs->headerName[i]);
         }
      }
      else {
         commonArgs->headerName[i] = '_';
      }
   }
   fprintf( commonArgs->fpHeader, "#ifndef %s\n", commonArgs->headerName );
   fprintf( commonArgs->fpHeader, "#define %s\n\n", commonArgs->headerName );
   fprintf( commonArgs->fpHeader, "#ifdef __cplusplus\n" );
   fprintf( commonArgs->fpHeader, "extern \"C\" {\n" );
   fprintf( commonArgs->fpHeader, "#endif\n\n" );
   fprintf( commonArgs->fpHeader, "%s\n\n", g_barrier );
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

void navigate( errp_common * commonArgs,
               xmlNode     * root )
{
   xmlNode * node = NULL, * group = NULL;
   xmlChar * version;
   xmlChar * enumName = NULL;
   
   version = root->properties->children->content;
   
   node = root->children;
   
   /* Go to the first element */
   while ( node->type != XML_ELEMENT_NODE ) { node = node->next; }

   /* Copyrigth information is optional */
   if ( xmlStrcmp( node->name, BAD_CAST "copyright") == 0 ) {
      doTopOfFile( commonArgs, version, node );
      node = node->next;
   }
   else {
      doTopOfFile( commonArgs, version, NULL );
   }

   /* 
    * enum information is only present if the target is an enum. If not
    * present, we use "#define" instead.
    */
   while ( node->type != XML_ELEMENT_NODE ) { node = node->next; }

   commonArgs->writingEnum = 0;
   if ( xmlStrcmp( node->name, BAD_CAST "enumname" ) == 0 ) {
      commonArgs->writingEnum = 1;
      enumName = stripText( node->children->content );
      fprintf( commonArgs->fpHeader, "enum %s\n{\n", enumName );
      node = node->next;
   }

   while ( node->type != XML_ELEMENT_NODE ) { node = node->next; }
   /* The allocated memory for the prefix is free at the end of main() */
   commonArgs->prefix = stripText( node->children->content );

   /*
    * This one is a bit special - we have to know if it's the last group 
    * or not (for enums, the last error of the last group is special - it's
    * the only one not terminated by a comma).
    */
   node = node->next;
   while ( node != NULL ) {
      if ( node->type == XML_ELEMENT_NODE ) {
         if ( group != NULL ) addGroup( commonArgs, group, 0 );
         group = node;
      }
      node = node->next; 
   }
   addGroup( commonArgs, group, 1 );

   if ( enumName ) {
      fprintf( commonArgs->fpHeader, "};\n\n" );
      fprintf( commonArgs->fpHeader, "typedef %s %s;\n\n", enumName, enumName );
      free( enumName );
   }
   fprintf( commonArgs->fpHeader, "%s\n\n", g_barrier );
   fprintf( commonArgs->fpHeader, "#ifdef __cplusplus\n" );
   fprintf( commonArgs->fpHeader, "}\n#endif\n\n" );
   fprintf( commonArgs->fpHeader, "#endif /* %s */\n\n", 
            commonArgs->headerName );
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

int main( int argc, char * argv[] )
{
   xmlParserCtxtPtr context = NULL;  /* The parser context */
   xmlNode * root = NULL;            /* The root node */
   
   struct errp_common commonArgs;

   if (argc != 4) {
      fprintf( stderr, "Usage: %s --header header_file input_xml_file\n", 
               argv[0] );
      return 1;
   }
   if ( strcmp("--header",argv[1]) == 0 ) commonArgs.headerName = argv[2];

   commonArgs.xmlFileName = argv[3];
   
   commonArgs.fpHeader = fopen( commonArgs.headerName, "w" );
   if ( commonArgs.fpHeader == NULL ) {
      fprintf( stderr, "Error opening the header file %s.\n", 
               commonArgs.headerName );
      return 1;
   }
   commonArgs.prefix = NULL;
   commonArgs.errorCount = commonArgs.groupCount = 0;
   
   /*
    * this initialize the library and check potential ABI mismatches
    * between the version it was compiled for and the actual shared
    * library used.
    */
   LIBXML_TEST_VERSION

   context = xmlNewParserCtxt();
   if ( context == NULL ) {
      fprintf(stderr, "Error allocating the parser context\n");
      return 1;
   }

   /* We create the document and validate in one go */
   commonArgs.document = xmlCtxtReadFile( context, 
                                          commonArgs.xmlFileName, 
                                          NULL,
                                          XML_PARSE_DTDVALID );
   if ( commonArgs.document == NULL ) {
      fprintf( stderr, "Error while parsing the input file: %s\n", 
               commonArgs.xmlFileName );
      return 1;
   }
   if ( context->valid == 0 ) {
      fprintf( stderr, "Error: document validation failed\n" );
      return 1;
   }
   
   root = xmlDocGetRootElement( commonArgs.document );

   navigate( &commonArgs, root );

   xmlFreeDoc( commonArgs.document );

   xmlFreeParserCtxt( context );

   xmlCleanupParser();

   fclose( commonArgs.fpHeader );
   if ( commonArgs.prefix != NULL ) free(commonArgs.prefix);
      
   return 0;
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

