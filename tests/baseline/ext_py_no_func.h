/*
 * This file was generated by the program errorParser
 * using the input file ../tests/xml/generic.xml.
 * Date: Wed Dec 31 14:47:57 2008.
 *
 * The version of the XML error file is 0.3.
 *
 * Copyright (C) 2006-2008 Daniel Prevost
 *
 * This file is part of Photon (photonsoftware.org).
 *
 * This file may be distributed and/or modified under the terms of the 
 * GNU General Public License version 2 as published by the Free 
 * Software Foundation and appearing in the file COPYING included in 
 * the packaging of this library.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

#ifndef EXT_PY_NO_FUNC_H
#define EXT_PY_NO_FUNC_H

#ifdef __cplusplus
extern "C" {
#endif

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

#include "Python.h"

PyObject * AddErrors(void)
{
    PyObject * errors = NULL, * errorNames = NULL, * value = NULL, * key = NULL;
    int errcode;

    errors = PyDict_New();
    if ( errors == NULL ) return NULL;

    errorNames = PyDict_New();
    if ( errorNames == NULL ) {
        Py_DECREF(errors);
        return NULL;
    }

    /*
     * No error...
     */
    value = PyInt_FromLong(0);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OK");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Abnormal internal error. It should not happen!
     */
    value = PyInt_FromLong(666);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INTERNAL_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Cannot get a lock on a system object, the engine is "busy".
     *
     * This might be the result of either a very busy system where 
     * unused cpu cycles are rare or a lock might be held by a crashed 
     * process.
     */
    value = PyInt_FromLong(1);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("ENGINE_BUSY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Not enough memory in the PSO.
     */
    value = PyInt_FromLong(2);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NOT_ENOUGH_PSO_MEMORY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Not enough heap memory (non-PSO memory).
     */
    value = PyInt_FromLong(3);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NOT_ENOUGH_HEAP_MEMORY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * There are not enough resources to correctly process the call.
     *
     * Possible explanations: it might be a lack of POSIX semaphores on 
     * systems where atomic locks are implemented that way or a failure 
     * in initializing a pthread_mutex (or on Windows, a critical 
     * section).
     */
    value = PyInt_FromLong(4);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NOT_ENOUGH_RESOURCES");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The provided handle is of the wrong type (C API). This could 
     * happen if you provide a queue handle to access a hash map or 
     * something similar. It can also occur if you try to access an 
     * object after closing it.
     *
     * If you are seeing this error for the C++ API (or some other 
     * object-oriented interface), you've just found an internal 
     * error... (the handle is encapsulated and cannot be modified 
     * using the public interface).
     */
    value = PyInt_FromLong(5);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("WRONG_TYPE_HANDLE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The provided handle is NULL.
     */
    value = PyInt_FromLong(6);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NULL_HANDLE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * One of the arguments of an API function is an invalid NULL 
     * pointer.
     */
    value = PyInt_FromLong(7);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NULL_POINTER");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * An invalid length was provided as an argument to an API 
     * function.
     *
     * This invalid length will usually indicate that the length value 
     * is set to zero.
     */
    value = PyInt_FromLong(8);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_LENGTH");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The process was already initialized. One possibility: was 
     * psoInit() called for a second time?
     */
    value = PyInt_FromLong(21);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("PROCESS_ALREADY_INITIALIZED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The process was not properly initialized. One possibility: was 
     * psoInit() called?
     */
    value = PyInt_FromLong(22);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("PROCESS_NOT_INITIALIZED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The watchdog address is invalid (empty string, NULL pointer, 
     * etc.).
     */
    value = PyInt_FromLong(23);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_WATCHDOG_ADDRESS");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * API - memory-file version mismatch.
     */
    value = PyInt_FromLong(24);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INCOMPATIBLE_VERSIONS");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Generic socket error.
     */
    value = PyInt_FromLong(25);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("SOCKET_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Socket error when trying to connect to the watchdog.
     */
    value = PyInt_FromLong(26);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("CONNECT_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Socket error when trying to send a request to the watchdog.
     */
    value = PyInt_FromLong(27);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("SEND_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Socket error when trying to receive a reply from the watchdog.
     */
    value = PyInt_FromLong(28);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("RECEIVE_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The shared-memory backstore file is missing. The name of this 
     * file is provided by the server (quasar) - if it is missing, 
     * something really weird is going on.
     */
    value = PyInt_FromLong(29);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("BACKSTORE_FILE_MISSING");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Generic i/o error when attempting to open the shared memory.
     */
    value = PyInt_FromLong(30);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("ERROR_OPENING_MEMORY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Error accessing the directory for the log files or error opening 
     * the log file itself.
     */
    value = PyInt_FromLong(41);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("LOGFILE_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Cannot get a lock on the session (a pthread_mutex or a critical 
     * section on Windows).
     */
    value = PyInt_FromLong(42);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("SESSION_CANNOT_GET_LOCK");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * An attempt was made to use a session object (a session handle) 
     * after this session was terminated.
     */
    value = PyInt_FromLong(43);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("SESSION_IS_TERMINATED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Permitted characters for names are alphanumerics, spaces (' '), 
     * dashes ('-') and underlines ('_'). The first character must be 
     * alphanumeric.
     */
    value = PyInt_FromLong(51);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_OBJECT_NAME");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The object was not found (but its folder does exist).
     */
    value = PyInt_FromLong(52);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NO_SUCH_OBJECT");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * One of the parent folder of an object does not exist.
     */
    value = PyInt_FromLong(53);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NO_SUCH_FOLDER");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Attempt to create an object which already exists.
     */
    value = PyInt_FromLong(54);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_ALREADY_PRESENT");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The object (data container) is empty.
     */
    value = PyInt_FromLong(55);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("IS_EMPTY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Attempt to create an object of an unknown object type or to open 
     * an object of the wrong type.
     */
    value = PyInt_FromLong(56);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("WRONG_OBJECT_TYPE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Cannot get lock on the object. This might be the result of 
     * either a very busy system where unused cpu cycles are rare or a 
     * lock might be held by a crashed process.
     */
    value = PyInt_FromLong(57);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_CANNOT_GET_LOCK");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The search/iteration reached the end without finding a new 
     * item/record.
     */
    value = PyInt_FromLong(58);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("REACHED_THE_END");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * An invalid value was used for a psoIteratorType parameter.
     */
    value = PyInt_FromLong(59);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_ITERATOR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The name of the object is too long. The maximum length of a name 
     * cannot be more than PSO_MAX_NAME_LENGTH (or 
     * PSO_MAX_FULL_NAME_LENGTH for the fully qualified name).
     */
    value = PyInt_FromLong(60);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_NAME_TOO_LONG");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * You cannot delete a folder if there are still undeleted objects 
     * in it.
     *
     * Technical: a folder does not need to be empty to be deleted but 
     * all objects in it must be "marked as deleted" by the current 
     * session. This enables writing recursive deletions
     */
    value = PyInt_FromLong(61);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("FOLDER_IS_NOT_EMPTY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * An item with the same key was found.
     */
    value = PyInt_FromLong(62);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("ITEM_ALREADY_PRESENT");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The item was not found in the hash map.
     */
    value = PyInt_FromLong(63);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NO_SUCH_ITEM");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The object is scheduled to be deleted soon. Operations on this 
     * data container are not permitted at this time.
     */
    value = PyInt_FromLong(64);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_IS_DELETED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Object must be open first before you can access them.
     */
    value = PyInt_FromLong(65);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_NOT_INITIALIZED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The data item is scheduled to be deleted soon or was just 
     * created and is not committed. Operations on this data item are 
     * not permitted at this time.
     */
    value = PyInt_FromLong(66);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("ITEM_IS_IN_USE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The data item is scheduled to be deleted soon. Operations on 
     * this data container are not permitted at this time.
     */
    value = PyInt_FromLong(67);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("ITEM_IS_DELETED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The object is scheduled to be deleted soon or was just created 
     * and is not committed. Operations on this object are not 
     * permitted at this time.
     */
    value = PyInt_FromLong(69);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_IS_IN_USE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The object is read-only and update operations 
     * (delete/insert/replace) on it are not permitted. at this time.
     */
    value = PyInt_FromLong(70);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("OBJECT_IS_READ_ONLY");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * All read-only objects open for updates (as temporary objects) 
     * must be closed prior to doing a commit on the session.
     */
    value = PyInt_FromLong(71);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("NOT_ALL_EDIT_ARE_CLOSED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Read-only objects are not updated very frequently and therefore 
     * only a single editing copy is allowed. To allow concurrent 
     * editors (either all working on the same copy or each working 
     * with its own copy would have been be possible but was deemed 
     * unnecessary.
     */
    value = PyInt_FromLong(72);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("A_SINGLE_UPDATER_IS_ALLOWED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The number of fields in the data definition is invalid - either 
     * zero or greater than PSO_MAX_FIELDS (defined in 
     * photon/psoCommon.h).
     */
    value = PyInt_FromLong(101);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_NUM_FIELDS");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The data type of the field definition does not correspond to one 
     * of the data type defined in the enum psoFieldType 
     * (photon/psoCommon.h). or you've used PSO_VAR_STRING or 
     * PSO_VAR_BINARY at the wrong place.
     *
     * Do not forget that PSO_VAR_STRING and PSO_VAR_BINAR can only be 
     * used for the last field of your data definition.
     */
    value = PyInt_FromLong(102);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_FIELD_TYPE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The length of an integer field (PSO_INTEGER) is invalid. Valid 
     * values are 1, 2, 4 and 8.
     */
    value = PyInt_FromLong(103);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_FIELD_LENGTH_INT");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The length of a field (string or binary) is invalid. Valid 
     * values are all numbers greater than zero and less than 
     * 4294967296 (4 Giga).
     */
    value = PyInt_FromLong(104);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_FIELD_LENGTH");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The name of the field contains invalid characters. Valid 
     * characters are the standard ASCII alphanumerics ([a-zA-Z0-9]) 
     * and the underscore ('_'). The first character of the name must 
     * be letter.
     */
    value = PyInt_FromLong(105);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_FIELD_NAME");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The name of the field is already used by another field in the 
     * current definition.
     *
     * Note: at the moment field names are case sensitive (for example 
     * "account_id" and "Account_Id" are considered different). This 
     * might be changed eventually so this practice should be avoided.
     */
    value = PyInt_FromLong(106);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("DUPLICATE_FIELD_NAME");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The precision of a PSO_DECIMAL field is either zero or over the 
     * limit for this type (set at 30 currently). Note: precision is 
     * the number of digits in a number.
     */
    value = PyInt_FromLong(107);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_PRECISION");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The scale of a PSO_DECIMAL field is invalid (greater than the 
     * value of precision. Note: scale is the number of digits to the 
     * right of the decimal separator in a number.
     */
    value = PyInt_FromLong(108);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_SCALE");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The key definition for a hash map is either invalid or missing.
     */
    value = PyInt_FromLong(109);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("INVALID_KEY_DEF");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Error reading the XML buffer stream.
     *
     * No validation is done at this point. Therefore the error is 
     * likely something like a missing end-tag or some other 
     * non-conformance to the XML's syntax rules.
     *
     * A simple Google search for "well-formed xml" returns many web 
     * sites that describe the syntax rules for XML. You can also use 
     * the program xmllint (included in the distribution of libxm2) to 
     * pinpoint the issue.
     */
    value = PyInt_FromLong(201);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_READ_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The root element is not the expected root, <folder> and similar.
     */
    value = PyInt_FromLong(202);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_INVALID_ROOT");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The root element must have an attribute named schemaLocation (in 
     * the namespace "http://www.w3.org/2001/XMLSchema-instance") to 
     * point to the schema use for the xml buffer stream.
     *
     * This attribute is in two parts separated by a space. The code 
     * expects the file name of the schema in the second element of 
     * this attribute.
     */
    value = PyInt_FromLong(203);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_NO_SCHEMA_LOCATION");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The creation of a new schema parser context failed. There might 
     * be multiple reasons for this, for example, a memory-allocation 
     * failure in libxml2. However, the most likely reason is that the 
     * schema file is not at the location indicated by the attribute 
     * schemaLocation of the root element of the buffer stream.
     */
    value = PyInt_FromLong(204);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_PARSER_CONTEXT_FAILED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The parse operation of the schema failed. Most likely, there is 
     * an error in the schema. To debug this you can use xmllint (part 
     * of the libxml2 package).
     */
    value = PyInt_FromLong(205);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_PARSE_SCHEMA_FAILED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * The creation of a new schema validation context failed. There 
     * might be multiple reasons for this, for example, a 
     * memory-allocation failure in libxml2.
     */
    value = PyInt_FromLong(206);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_VALID_CONTEXT_FAILED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Document validation for the xml buffer failed. To debug this 
     * problem you can use xmllint (part of the libxml2 package).
     */
    value = PyInt_FromLong(207);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("XML_VALIDATION_FAILED");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    /*
     * Abnormal internal error with sem_destroy. It should not happen! 
     * It could indicate that the memory allocated for the semaphore 
     * was corrupted (errno = EINVAL) or that the reference counting is 
     * wrong (errno = EBUSY). Please contact us.
     */
    value = PyInt_FromLong(601);
    if ( value == NULL ) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    key = PyString_FromString("SEM_DESTROY_ERROR");
    if ( key == NULL ) {
        Py_DECREF(value);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errors, key, value);
    if (errcode != 0) {
        Py_DECREF(value);
        Py_DECREF(key);
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }
    errcode = PyDict_SetItem(errorNames, value, key);
    Py_DECREF(value);
    Py_DECREF(key);
    if (errcode != 0) {
        PyDict_Clear(errors);
        Py_DECREF(errors);
        PyDict_Clear(errorNames);
        Py_DECREF(errorNames);
        return NULL;
    }

    return Py_BuildValue("OO", errors, errorNames);
}

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

#ifdef __cplusplus
}
#endif

#endif /* EXT_PY_NO_FUNC_H */

/* --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-- */

