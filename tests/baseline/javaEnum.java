/*
 * This file was generated by the program errorParser
 * using the input file ../tests/xml/generic.xml.
 * Date: Mon Feb 09 15:10:52 2009.
 *
 * The version of the XML error file is 0.3.
 *
 * Copyright (C) 2006-2008 Daniel Prevost
 *
 * This file is part of Photon (photonsoftware.org).
 *
 * This file may be distributed and/or modified under the terms of the 
 * GNU General Public License version 2 as published by the Free 
 * Software Foundation and appearing in the file COPYING included in 
 * the packaging of this library.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

// --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--

package org.errorParser;

import java.util.*;

public enum javaEnum {

    // No error...
    OK(0) {
        String getMessage() { return "No error (adding a dummy percent to test this feature)"; } },

    // Abnormal internal error. It should not happen!
    INTERNAL_ERROR(666) {
        String getMessage() { return "Abnormal internal error."; } },

    // Cannot get a lock on a system object, the engine is "busy".
    //
    // This might be the result of either a very busy system where 
    // unused cpu cycles are rare or a lock might be held by a crashed 
    // process.
    ENGINE_BUSY(1) {
        String getMessage() { return "Cannot get a lock on a system object, the engine is \"busy\"."; } },

    // Not enough memory in the PSO.
    NOT_ENOUGH_PSO_MEMORY(2) {
        String getMessage() { return "Not enough memory in the PSO."; } },

    // Not enough heap memory (non-PSO memory).
    NOT_ENOUGH_HEAP_MEMORY(3) {
        String getMessage() { return "Not enough heap memory (non-PSO memory)."; } },

    // There are not enough resources to correctly process the call.
    //
    // Possible explanations: it might be a lack of POSIX semaphores on 
    // systems where atomic locks are implemented that way or a failure 
    // in initializing a pthread_mutex (or on Windows, a critical 
    // section).
    NOT_ENOUGH_RESOURCES(4) {
        String getMessage() { return "There are not enough resources to correctly process the call."; } },

    // The provided handle is of the wrong type (C API). This could 
    // happen if you provide a queue handle to access a hash map or 
    // something similar. It can also occur if you try to access an 
    // object after closing it.
    //
    // If you are seeing this error for the C++ API (or some other 
    // object-oriented interface), you've just found an internal 
    // error... (the handle is encapsulated and cannot be modified 
    // using the public interface).
    WRONG_TYPE_HANDLE(5) {
        String getMessage() { return "The provided handle is of the wrong type."; } },

    // The provided handle is NULL.
    NULL_HANDLE(6) {
        String getMessage() { return "The provided handle is NULL."; } },

    // One of the arguments of an API function is an invalid NULL 
    // pointer.
    NULL_POINTER(7) {
        String getMessage() { return "One of the arguments of an API function is an invalid NULL pointer."; } },

    // An invalid length was provided as an argument to an API 
    // function.
    //
    // This invalid length will usually indicate that the length value 
    // is set to zero.
    INVALID_LENGTH(8) {
        String getMessage() { return "An invalid length was provided."; } },

    // The process was already initialized. One possibility: was 
    // psoInit() called for a second time?
    PROCESS_ALREADY_INITIALIZED(21) {
        String getMessage() { return "The process was already initialized."; } },

    // The process was not properly initialized. One possibility: was 
    // psoInit() called?
    PROCESS_NOT_INITIALIZED(22) {
        String getMessage() { return "The process was not properly initialized."; } },

    // The watchdog address is invalid (empty string, NULL pointer, 
    // etc.).
    INVALID_WATCHDOG_ADDRESS(23) {
        String getMessage() { return "The watchdog address is invalid (empty string, NULL pointer, etc.)."; } },

    // API - memory-file version mismatch.
    INCOMPATIBLE_VERSIONS(24) {
        String getMessage() { return "API - memory-file version mismatch."; } },

    // Generic socket error.
    SOCKET_ERROR(25) {
        String getMessage() { return "Generic socket error."; } },

    // Socket error when trying to connect to the watchdog.
    CONNECT_ERROR(26) {
        String getMessage() { return "Socket error when trying to connect to the watchdog."; } },

    // Socket error when trying to send a request to the watchdog.
    SEND_ERROR(27) {
        String getMessage() { return "Socket error when trying to send a request to the watchdog."; } },

    // Socket error when trying to receive a reply from the watchdog.
    RECEIVE_ERROR(28) {
        String getMessage() { return "Socket error when trying to receive a reply from the watchdog."; } },

    // The shared-memory backstore file is missing. The name of this 
    // file is provided by the server (quasar) - if it is missing, 
    // something really weird is going on.
    BACKSTORE_FILE_MISSING(29) {
        String getMessage() { return "The shared-memory backstore file is missing."; } },

    // Generic i/o error when attempting to open the shared memory.
    ERROR_OPENING_MEMORY(30) {
        String getMessage() { return "Generic i/o error when attempting to open the shared memory."; } },

    // Error accessing the directory for the log files or error opening 
    // the log file itself.
    LOGFILE_ERROR(41) {
        String getMessage() { return "Error accessing the directory for the log files or error opening the log file itself."; } },

    // Cannot get a lock on the session (a pthread_mutex or a critical 
    // section on Windows).
    SESSION_CANNOT_GET_LOCK(42) {
        String getMessage() { return "Cannot get a lock on the session (a pthread_mutex or a critical section on Windows)."; } },

    // An attempt was made to use a session object (a session handle) 
    // after this session was terminated.
    SESSION_IS_TERMINATED(43) {
        String getMessage() { return "An attempt was made to use a session object (a session handle) after this session was terminated."; } },

    // Permitted characters for names are alphanumerics, spaces (' '), 
    // dashes ('-') and underlines ('_'). The first character must be 
    // alphanumeric.
    INVALID_OBJECT_NAME(51) {
        String getMessage() { return "Permitted characters for names are alphanumerics, spaces (\' \'), dashes (\'-\') and underlines (\'_\'). The first character must be alphanumeric."; } },

    // The object was not found (but its folder does exist).
    NO_SUCH_OBJECT(52) {
        String getMessage() { return "The object was not found (but its folder does exist)."; } },

    // One of the parent folder of an object does not exist.
    NO_SUCH_FOLDER(53) {
        String getMessage() { return "One of the parent folder of an object does not exist."; } },

    // Attempt to create an object which already exists.
    OBJECT_ALREADY_PRESENT(54) {
        String getMessage() { return "Attempt to create an object which already exists."; } },

    // The object (data container) is empty.
    IS_EMPTY(55) {
        String getMessage() { return "The object (data container) is empty."; } },

    // Attempt to create an object of an unknown object type or to open 
    // an object of the wrong type.
    WRONG_OBJECT_TYPE(56) {
        String getMessage() { return "Attempt to create an object of an unknown object type or to open an object of the wrong type."; } },

    // Cannot get lock on the object. This might be the result of 
    // either a very busy system where unused cpu cycles are rare or a 
    // lock might be held by a crashed process.
    OBJECT_CANNOT_GET_LOCK(57) {
        String getMessage() { return "Cannot get lock on the object. This might be the result of either a very busy system where unused cpu cycles are rare or a lock might be held by a crashed process."; } },

    // The search/iteration reached the end without finding a new 
    // item/record.
    REACHED_THE_END(58) {
        String getMessage() { return "The search/iteration reached the end without finding a new item/record."; } },

    // An invalid value was used for a psoIteratorType parameter.
    INVALID_ITERATOR(59) {
        String getMessage() { return "An invalid value was used for a psoIteratorType parameter."; } },

    // The name of the object is too long. The maximum length of a name 
    // cannot be more than PSO_MAX_NAME_LENGTH (or 
    // PSO_MAX_FULL_NAME_LENGTH for the fully qualified name).
    OBJECT_NAME_TOO_LONG(60) {
        String getMessage() { return "The name of the object is too long. The maximum length of a name cannot be more than PSO_MAX_NAME_LENGTH (or PSO_MAX_FULL_NAME_LENGTH for the fully qualified name)."; } },

    // You cannot delete a folder if there are still undeleted objects 
    // in it.
    //
    // Technical: a folder does not need to be empty to be deleted but 
    // all objects in it must be "marked as deleted" by the current 
    // session. This enables writing recursive deletions
    FOLDER_IS_NOT_EMPTY(61) {
        String getMessage() { return "You cannot delete a folder if there are still undeleted objects in it."; } },

    // An item with the same key was found.
    ITEM_ALREADY_PRESENT(62) {
        String getMessage() { return "An item with the same key was found."; } },

    // The item was not found in the hash map.
    NO_SUCH_ITEM(63) {
        String getMessage() { return "The item was not found in the hash map."; } },

    // The object is scheduled to be deleted soon. Operations on this 
    // data container are not permitted at this time.
    OBJECT_IS_DELETED(64) {
        String getMessage() { return "The object is scheduled to be deleted soon. Operations on this data container are not permitted at this time."; } },

    // Object must be open first before you can access them.
    OBJECT_NOT_INITIALIZED(65) {
        String getMessage() { return "Object must be open first before you can access them."; } },

    // The data item is scheduled to be deleted soon or was just 
    // created and is not committed. Operations on this data item are 
    // not permitted at this time.
    ITEM_IS_IN_USE(66) {
        String getMessage() { return "The data item is scheduled to be deleted soon or was just created and is not committed. Operations on this data item are not permitted at this time."; } },

    // The data item is scheduled to be deleted soon. Operations on 
    // this data container are not permitted at this time.
    ITEM_IS_DELETED(67) {
        String getMessage() { return "The data item is scheduled to be deleted soon. Operations on this data container are not permitted at this time."; } },

    // The object is scheduled to be deleted soon or was just created 
    // and is not committed. Operations on this object are not 
    // permitted at this time.
    OBJECT_IS_IN_USE(69) {
        String getMessage() { return "The object is scheduled to be deleted soon or was just created and is not committed. Operations on this object are not permitted at this time."; } },

    // The object is read-only and update operations 
    // (delete/insert/replace) on it are not permitted. at this time.
    OBJECT_IS_READ_ONLY(70) {
        String getMessage() { return "The object is read-only and update operations on it are not permitted."; } },

    // All read-only objects open for updates (as temporary objects) 
    // must be closed prior to doing a commit on the session.
    NOT_ALL_EDIT_ARE_CLOSED(71) {
        String getMessage() { return "All edits must be closed before a commit."; } },

    // Read-only objects are not updated very frequently and therefore 
    // only a single editing copy is allowed. To allow concurrent 
    // editors (either all working on the same copy or each working 
    // with its own copy would have been be possible but was deemed 
    // unnecessary.
    A_SINGLE_UPDATER_IS_ALLOWED(72) {
        String getMessage() { return "Read-only objects can only have one updater at a time."; } },

    // The number of fields in the data definition is invalid - either 
    // zero or greater than PSO_MAX_FIELDS (defined in 
    // photon/psoCommon.h).
    INVALID_NUM_FIELDS(101) {
        String getMessage() { return "The number of fields in the data definition is invalid."; } },

    // The data type of the field definition does not correspond to one 
    // of the data type defined in the enum psoFieldType 
    // (photon/psoCommon.h). or you've used PSO_VAR_STRING or 
    // PSO_VAR_BINARY at the wrong place.
    //
    // Do not forget that PSO_VAR_STRING and PSO_VAR_BINAR can only be 
    // used for the last field of your data definition.
    INVALID_FIELD_TYPE(102) {
        String getMessage() { return "The data type of the field definition is invalid."; } },

    // The length of an integer field (PSO_INTEGER) is invalid. Valid 
    // values are 1, 2, 4 and 8.
    INVALID_FIELD_LENGTH_INT(103) {
        String getMessage() { return "The length of an integer field (PSO_INTEGER) is invalid."; } },

    // The length of a field (string or binary) is invalid. Valid 
    // values are all numbers greater than zero and less than 
    // 4294967296 (4 Giga).
    INVALID_FIELD_LENGTH(104) {
        String getMessage() { return "The length of a field (string or binary) is invalid."; } },

    // The name of the field contains invalid characters. Valid 
    // characters are the standard ASCII alphanumerics ([a-zA-Z0-9]) 
    // and the underscore ('_'). The first character of the name must 
    // be letter.
    INVALID_FIELD_NAME(105) {
        String getMessage() { return "The name of the field contains invalid characters."; } },

    // The name of the field is already used by another field in the 
    // current definition.
    //
    // Note: at the moment field names are case sensitive (for example 
    // "account_id" and "Account_Id" are considered different). This 
    // might be changed eventually so this practice should be avoided.
    DUPLICATE_FIELD_NAME(106) {
        String getMessage() { return "The name of the field is already used by another field in the current definition."; } },

    // The precision of a PSO_DECIMAL field is either zero or over the 
    // limit for this type (set at 30 currently). Note: precision is 
    // the number of digits in a number.
    INVALID_PRECISION(107) {
        String getMessage() { return "The precision of a PSO_DECIMAL field is invalid."; } },

    // The scale of a PSO_DECIMAL field is invalid (greater than the 
    // value of precision. Note: scale is the number of digits to the 
    // right of the decimal separator in a number.
    INVALID_SCALE(108) {
        String getMessage() { return "The scale of a PSO_DECIMAL field is invalid."; } },

    // The key definition for a hash map is either invalid or missing.
    INVALID_KEY_DEF(109) {
        String getMessage() { return "The key definition is invalid or missing."; } },

    // Error reading the XML buffer stream.
    //
    // No validation is done at this point. Therefore the error is 
    // likely something like a missing end-tag or some other 
    // non-conformance to the XML's syntax rules.
    //
    // A simple Google search for "well-formed xml" returns many web 
    // sites that describe the syntax rules for XML. You can also use 
    // the program xmllint (included in the distribution of libxm2) to 
    // pinpoint the issue.
    XML_READ_ERROR(201) {
        String getMessage() { return "Error reading the XML buffer."; } },

    // The root element is not the expected root, <folder> and similar.
    XML_INVALID_ROOT(202) {
        String getMessage() { return "The root element is not the expected root."; } },

    // The root element must have an attribute named schemaLocation (in 
    // the namespace "http://www.w3.org/2001/XMLSchema-instance") to 
    // point to the schema use for the xml buffer stream.
    //
    // This attribute is in two parts separated by a space. The code 
    // expects the file name of the schema in the second element of 
    // this attribute.
    XML_NO_SCHEMA_LOCATION(203) {
        String getMessage() { return "The attribute xsi:schemaLocation was not found or is invalid."; } },

    // The creation of a new schema parser context failed. There might 
    // be multiple reasons for this, for example, a memory-allocation 
    // failure in libxml2. However, the most likely reason is that the 
    // schema file is not at the location indicated by the attribute 
    // schemaLocation of the root element of the buffer stream.
    XML_PARSER_CONTEXT_FAILED(204) {
        String getMessage() { return "The creation of a new schema parser context failed."; } },

    // The parse operation of the schema failed. Most likely, there is 
    // an error in the schema. To debug this you can use xmllint (part 
    // of the libxml2 package).
    XML_PARSE_SCHEMA_FAILED(205) {
        String getMessage() { return "Failure when parsing the XML schema."; } },

    // The creation of a new schema validation context failed. There 
    // might be multiple reasons for this, for example, a 
    // memory-allocation failure in libxml2.
    XML_VALID_CONTEXT_FAILED(206) {
        String getMessage() { return "The creation of a new XML Schemas validation context failed."; } },

    // Document validation for the xml buffer failed. To debug this 
    // problem you can use xmllint (part of the libxml2 package).
    XML_VALIDATION_FAILED(207) {
        String getMessage() { return "Document validation for the xml buffer failed."; } },

    // Abnormal internal error with sem_destroy. It should not happen! 
    // It could indicate that the memory allocated for the semaphore 
    // was corrupted (errno = EINVAL) or that the reference counting is 
    // wrong (errno = EBUSY). Please contact us.
    SEM_DESTROY_ERROR(601) {
        String getMessage() { return "Abnormal internal error with sem_destroy."; } };

    // --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--

    private final int errcode;

    javaEnum(int errcode) { 
        this.errcode = errcode;
    }

    public int getErrorNumber() { return errcode; }

    abstract String getMessage();

    private static final HashMap<Integer,javaEnum> reverseLookup = new HashMap<Integer,javaEnum>();

    static {
        for ( javaEnum err : javaEnum.values() ) {
            reverseLookup.put( err.getErrorNumber(), err );
        }
    }

    public static javaEnum getEnum(int errcode) {
        return reverseLookup.get(errcode);
    }

}

// --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--

